\section{WEB TABANLI TÜRKİYE GEZGİN HARİTASI UYGULAMASI}

\subsection{Uygulama Mimarisi ve Teknoloji Yığını}

Gezgin Haritası uygulaması, modern web teknolojileri kullanılarak geliştirilmiş full-stack bir web uygulamasıdır. Uygulama, client-server mimarisine dayalı olarak tasarlanmış ve kullanıcılara Türkiye'nin farklı şehirlerini keşfetme imkanı sunmaktadır.

\subsubsection{Frontend Yapısı}

Frontend kısmı, HTML5, CSS3 ve vanilla JavaScript kullanılarak geliştirilmiştir. Harita görselleştirmesi için \textbf{Leaflet.js} kütüphanesi entegre edilmiş, Türkiye haritası ise SVG formatında interaktif hale getirilmiştir. Kullanıcı arayüzü responsive tasarım prensipleriyle oluşturulmuş, farklı ekran boyutlarında sorunsuz çalışması sağlanmıştır.

\subsubsection{Backend Yapısı}

Backend, \textbf{Node.js} ve \textbf{Express.js} framework'ü kullanılarak geliştirilmiştir. RESTful API yapısı benimsenmiş, veritabanı işlemleri için \textbf{MySQL} tercih edilmiştir. Kullanıcı kimlik doğrulaması \textbf{JWT (JSON Web Token)} ile sağlanmış, şifre güvenliği için \textbf{bcrypt} kullanılmıştır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
import express from "express";
import mysql from "mysql2/promise";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

const app = express();
const JWT_SECRET = process.env.JWT_SECRET;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));
\end{lstlisting}
    \caption{Express.js backend başlangıç yapılandırması}
    \label{lst:express-setup}
\end{figure}

\textbf{Şekil \ref{lst:express-setup}}'de görüldüğü gibi, uygulama Express.js framework'ü ile başlatılmış, gerekli middleware'ler ve veritabanı bağlantısı yapılandırılmıştır.

\subsection{Kullanıcı Yönetimi}

\subsubsection{Giriş Ekranı}

Kullanıcılar uygulamayı kullanabilmek için öncelikle giriş yapmalıdır. \textbf{Şekil \ref{fig:giris-ekrani}}'de görüldüğü gibi, minimalist ve kullanıcı dostu bir giriş ekranı tasarlanmıştır.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{giris-ekrani.png}
    \caption{Kullanıcı giriş ekranı}
    \label{fig:giris-ekrani}
\end{figure}

\subsubsection{Frontend Giriş İşlemi}

Giriş formu, JavaScript ile asenkron şekilde işlenmektedir. Kullanıcı bilgileri doğrulandıktan sonra JWT token alınmakta ve \texttt{localStorage}'da saklanmaktadır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
async function handleLogin(email, password) {
  try {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    
    const data = await res.json();
    
    if (res.ok) {
      authToken = data.token;
      currentUser = data.user;
      localStorage.setItem('authToken', authToken);
      
      // Close modal and show content
      updateAuthUI();
      showContent();
    } else {
      showError(data.error || 'Giris basarisiz');
    }
  } catch (error) {
    console.error('Login error:', error);
    showError('Bir hata olustu. Lutfen tekrar deneyin.');
  }
}
\end{lstlisting}
    \caption{Frontend giriş işlemi}
    \label{lst:frontend-login}
\end{figure}

\textbf{Şekil \ref{lst:frontend-login}}'de kullanıcı giriş işleminin frontend tarafındaki implementasyonu gösterilmektedir. Fetch API kullanılarak asenkron POST isteği yapılmakta, başarılı girişte JWT token localStorage'a kaydedilmekte ve kullanıcı arayüzü güncellenmektedir.

\subsubsection{Kullanıcı Kaydı}

Yeni kullanıcılar sisteme kayıt olabilmektedir. Kayıt sırasında email, şifre, yaş ve yaşadıkları il bilgileri istenmektedir. \textbf{Şekil \ref{fig:kayit-ekrani}}'de kayıt ekranı görülmektedir.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{kayit-ekrani.png}
    \caption{Kullanıcı kayıt ekranı}
    \label{fig:kayit-ekrani}
\end{figure}

\subsubsection{Backend Kayıt API}

Kayıt sırasında kullanıcılardan email, şifre, yaş ve yaşadıkları il bilgileri istenmektedir. Backend'de detaylı validasyon yapılmaktadır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
app.post("/api/register", async (req, res) => {
  const { email, password, age, city_id } = req.body;
  
  // Email formati kontrolu
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return res.status(400).json({ 
      error: "Gecerli bir email adresi giriniz" 
    });
  }
  
  // Sadece @gmail.com uzantili mailleri kabul et
  if (!email.toLowerCase().endsWith('@gmail.com')) {
    return res.status(400).json({ 
      error: "Sadece @gmail.com adresleri kabul edilir" 
    });
  }
  
  // Sifreyi hash'le
  const hashedPassword = await bcrypt.hash(password, 10);
  
  await db.query(
    "INSERT INTO users (email, password, age, city_id) 
     VALUES (?, ?, ?, ?)",
    [email, hashedPassword, age, city_id]
  );
  
  res.json({ success: true });
});
\end{lstlisting}
    \caption{Kullanıcı kayıt API endpoint'i}
    \label{lst:register-api}
\end{figure}

\textbf{Şekil \ref{lst:register-api}}'de kullanıcı kaydı için oluşturulan API endpoint'i gösterilmektedir. Email validasyonu yapılmış, sadece Gmail adresleri kabul edilmekte ve şifreler bcrypt ile hash'lenerek veritabanına kaydedilmektedir.

\subsubsection{Kullanıcı Girişi ve JWT Token}

Kayıtlı kullanıcılar, email ve şifreleri ile sisteme giriş yapabilmektedir. Başarılı girişlerde JWT token üretilmekte ve bu token sonraki isteklerde authentication için kullanılmaktadır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;
  
  // Kullaniciyi bul
  const [users] = await db.query(
    "SELECT id, email, password FROM users WHERE email = ?",
    [email]
  );
  if (users.length === 0) {
    return res.status(401).json({ error: "Email veya sifre hatali" });
  }
  
  // Sifreyi bcrypt ile kontrol et
  const passwordMatch = await bcrypt.compare(password, users[0].password);
  if (!passwordMatch) {
    return res.status(401).json({ error: "Email veya sifre hatali" });
  }
  
  // JWT token olustur (7 gun gecerli)
  const token = jwt.sign(
    { userId: users[0].id, email: users[0].email },
    JWT_SECRET,
    { expiresIn: "7d" }
  );
  
  res.json({ success: true, token, user: users[0] });
});
\end{lstlisting}
    \caption{Kullanıcı giriş API endpoint'i ve JWT token üretimi}
    \label{lst:login-api}
\end{figure}

\textbf{Şekil \ref{lst:login-api}}'de giriş işlemi gösterilmektedir. Kullanıcı şifresi bcrypt ile doğrulanmakta ve başarılı girişte 7 gün geçerli bir JWT token üretilmektedir.

\subsection{İnteraktif Harita Arayüzü}

Giriş yaptıktan sonra kullanıcılar, Türkiye'nin tüm illerini içeren interaktif harita ile karşılaşmaktadır. \textbf{Şekil \ref{fig:harita-ekrani}}'de ana harita ekranı görülmektedir.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{harita-ekrani.png}
    \caption{İnteraktif Türkiye haritası ana ekran}
    \label{fig:harita-ekrani}
\end{figure}

Her il farklı renkte gösterilmekte ve 7 coğrafi bölge (Marmara, Ege, Akdeniz, İç Anadolu, Karadeniz, Doğu Anadolu, Güneydoğu Anadolu) renk kodlaması ile ayırt edilmektedir.

\subsubsection{SVG Harita Yapısı ve Bölge Tanımlaması}

JavaScript'te her il için bölge eşlemesi tanımlanmıştır. Bu sayede dinamik olarak her ile uygun CSS sınıfı atanabilmektedir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
const regionByCity = {
  // Marmara
  istanbul: 'region-marmara',
  ankara: 'region-central-anatolia',
  izmir: 'region-aegean',
  // ... diger iller
};

function initializeCityMap() {
  const cityPaths = 
    document.querySelectorAll("#svg-turkey-map path");
  
  // Bolge siniflarini uygula
  cityPaths.forEach(path => {
    const slug = path.getAttribute('data-city-name');
    if (slug && regionByCity[slug]) {
      path.classList.add(regionByCity[slug]);
    }
  });
}
\end{lstlisting}
    \caption{İl-bölge eşlemesi ve dinamik CSS sınıfı atama}
    \label{lst:region-mapping}
\end{figure}

\textbf{Şekil \ref{lst:region-mapping}}'de her ilin hangi coğrafi bölgeye ait olduğunu belirleyen JavaScript kodu gösterilmektedir. Bu eşleme sayesinde harita üzerindeki her il, bölgesine göre farklı bir renk koduyla gösterilmektedir.

\subsubsection{Harita Etkileşimleri}

Kullanıcılar harita üzerindeki illere tıklayarak ilgili ilin ilçelerini görebilmektedir. Event delegation pattern kullanılarak performans optimize edilmiştir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
// Event delegation ile SVG uzerinde tek listener
svgMap.addEventListener("click", function(event) {
  const path = event.target.closest('path');
  if (path && path.hasAttribute('data-city-name')) {
    const cityNameSlug = 
      path.getAttribute("data-city-name");
    const provinceName = path.getAttribute("title");
    
    // Secili ili vurgula
    if (selectedCityPath) {
      selectedCityPath.classList.remove('selected');
    }
    selectedCityPath = path;
    selectedCityPath.classList.add('selected');
    
    // Ilceleri goster
    showDistricts(cityNameSlug, provinceName);
  }
});
\end{lstlisting}
    \caption{Harita tıklama event handler'ı}
    \label{lst:map-click}
\end{figure}

\textbf{Şekil \ref{lst:map-click}}'de SVG harita üzerinde event delegation pattern'i kullanılarak gerçekleştirilen tıklama işlemi gösterilmektedir. Kullanıcı bir ile tıkladığında seçilen il vurgulanmakta ve o ile ait ilçeler gösterilmektedir.

\subsection{İlçeler Listesi}

Kullanıcı bir il seçtiğinde, o ile ait tüm ilçeler listelenmektedir. \textbf{Şekil \ref{fig:ankara-ilceleri}}'de Ankara'nın ilçeleri görülmektedir.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{ankara-ilceleri.png}
    \caption{Ankara ilçeleri listesi}
    \label{fig:ankara-ilceleri}
\end{figure}

\subsubsection{İlçeleri Getirme İşlemi}

İlçeler, backend API'den çekilmekte ve dinamik olarak DOM'a eklenmektedir. Her ilçe tıklanabilir bir buton olarak gösterilmektedir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
async function showDistricts(city) {
  // API cagrisi ile ilceleri getir
  const res = await fetch(
    `/api/districts?city=${encodeURIComponent(city)}`, 
    { headers: { 'Authorization': `Bearer ${authToken}` } }
  );
  
  const districts = await res.json();
  const list = document.getElementById("district-list");
  
  // Ilceleri DOM'a ekle
  list.innerHTML = districts.map(d => 
    `<li class="district-item" data-id="${d.id}">${d.name}</li>`
  ).join("");
  
  // Click event listener'lari ekle
  list.querySelectorAll('.district-item').forEach(item => {
    item.addEventListener('click', () => 
      showDistrictDetails(item.dataset.id)
    );
  });
}
\end{lstlisting}
    \caption{İlçeleri listeleme ve event listener ekleme}
    \label{lst:show-districts}
\end{figure}

\textbf{Şekil \ref{lst:show-districts}}'de ilçelerin backend API'den çekilmesi ve DOM'a dinamik olarak eklenmesi gösterilmektedir. Her ilçe tıklanabilir bir buton olarak oluşturulmakta ve click event listener'ı eklenmektedir.

\subsection{İlçe Detayları ve Gezilecek Yerler}

Kullanıcı bir ilçe seçtiğinde, o ilçeye ait detaylı bilgiler gösterilmektedir. \textbf{Şekil \ref{fig:ilce-detay}}'de Altındağ ilçesinin detay sayfası görülmektedir.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{ilce-detay.png}
    \caption{İlçe detay sayfası örneği (Altındağ)}
    \label{fig:ilce-detay}
\end{figure}

İlçe detayları üç ana kategoride sunulmaktadır:
\begin{enumerate}
    \item \textbf{Genel Bilgi}: İlçe hakkında genel açıklamalar
    \item \textbf{Gezilecek Yerler}: Doğa ve tarih kategorilerinde yerler
    \item \textbf{Yeme-İçme}: Bölgeye özgü restoranlar ve yemekler
\end{enumerate}

\subsubsection{İlçe Detaylarını Gösterme}

İlçe detayları dinamik olarak HTML içeriği oluşturularak gösterilmektedir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
async function showDistrictDetails(districtId) {
  const res = await fetch(`/api/district/${districtId}`, {
    headers: { 'Authorization': `Bearer ${authToken}` }
  });
  const district = await res.json();
  
  // Ilce detaylarini HTML template ile goster
  detailContainer.innerHTML = `
    <h2>${district.name}</h2>
    <section>
      <h3>Genel Bilgi</h3>
      <p>${district.general_info}</p>
    </section>
    <section>
      <h3>Gezilecek Yerler</h3>
      <p>${district.nature_places}</p>
      <p>${district.historical_places}</p>
    </section>
  `;
  detailContainer.style.display = "block";
}
\end{lstlisting}
    \caption{İlçe detaylarını dinamik HTML ile gösterme}
    \label{lst:show-district-details}
\end{figure}

\textbf{Şekil \ref{lst:show-district-details}}'de ilçe detaylarının kullanıcı arayüzünde nasıl gösterildiği görülmektedir. Backend API'den gelen veriler template literal kullanılarak HTML'e dönüştürülmekte ve DOM'a eklenmektedir.

\subsubsection{Backend İlçe Detayları API}

Backend'de ilçe detayları için özel bir API endpoint'i geliştirilmiştir. Bu endpoint, hem JSON dosyasından hem de MySQL veritabanından veri çekebilmektedir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
app.get("/api/district/:id", async (req, res) => {
  const districtId = req.params.id;
  
  // Ilce bilgisini veritabanindan getir
  const [districts] = await db.query(
    `SELECT d.id, d.name, c.name as city_name 
     FROM districts d 
     JOIN cities c ON d.city_id = c.id 
     WHERE d.id = ?`,
    [districtId]
  );
  const district = districts[0];
  
  // Detaylari JSON veya veritabanindan al
  const details = await getDistrictDetails(districtId);
  
  res.json({
    id: district.id,
    name: district.name,
    city_name: district.city_name,
    ...details
  });
});
\end{lstlisting}
    \caption{İlçe detayları API endpoint'i}
    \label{lst:district-api}
\end{figure}

\subsubsection{Türkçe Karakter Normalizasyonu}

Türkçe karakterlerin doğru eşleştirilmesi için özel bir normalizasyon fonksiyonu geliştirilmiştir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
function normalizeTurkish(str) {
  if (!str) return '';
  
  let normalized = str.normalize('NFD');
  
  normalized = normalized
    .replace(/[\u011F\u011E]/g, 'g')  // g, G
    .replace(/[\u00FC\u00DC]/g, 'u')  // u, U
    .replace(/[\u015F\u015E]/g, 's')  // s, S
    .replace(/[\u0131\u0130\u0049]/g, 'i')  // i, I, I
    .replace(/[\u00F6\u00D6]/g, 'o')  // o, O
    .replace(/[\u00E7\u00C7]/g, 'c')  // c, C
    .replace(/[\u0300-\u036f]/g, '')  // Diacritics
    .toLowerCase()
    .trim();
  
  return normalized;
}
\end{lstlisting}
    \caption{Türkçe karakter normalizasyon fonksiyonu}
    \label{lst:turkish-normalize}
\end{figure}

\textbf{Şekil \ref{lst:turkish-normalize}}'de Türkçe karakterlerin ASCII karşılıklarına dönüştürülmesi gösterilmektedir. Bu fonksiyon, şehir ve ilçe isimlerinin tutarlı şekilde eşleştirilmesini sağlamaktadır.

\subsection{Veritabanı Yapısı ve MySQL Bağlantısı}

Uygulama, MySQL veritabanına \texttt{mysql2/promise} paketi ile bağlanmaktadır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
import mysql from "mysql2/promise";

const db = await mysql.createConnection({
  host: "localhost",
  user: "root",
  password: "",
  database: "gezgin",
  charset: 'utf8mb4'
});
\end{lstlisting}
    \caption{MySQL veritabanı bağlantı konfigürasyonu}
    \label{lst:mysql-connection}
\end{figure}

Uygulama dört ana tablo kullanmaktadır: \texttt{cities} (iller), \texttt{districts} (ilçeler), \texttt{district\_de\-ta\-ils} (ilçe detayları) ve \texttt{users} (kullanıcılar).

\subsection{Rota Planlayıcı}

Gezgin Haritası uygulaması, kullanıcıların gezilecek yerler arasında optimal rotalar oluşturmasına imkan tanıyan bir rota planlayıcı özelliği sunmaktadır. Bu özellik sayesinde kullanıcılar, ziyaret etmek istedikleri yerleri seçerek en verimli güzergahı belirleyebilmektedir.

\subsubsection{Rota Planlayıcı Arayüzü}

\textbf{Şekil \ref{fig:rota-planlayici}}'de görüldüğü gibi, rota planlayıcı arayüzü interaktif bir harita ve yan panel içermektedir. Kullanıcılar:

\begin{itemize}
    \item Yer seçimi yaparak rotalarına duraklar ekleyebilmektedir
    \item Seçtikleri yerler arasındaki toplam mesafeyi görebilmektedir
    \item Rotayı optimize ederek en kısa yolu bulabilmektedir
    \item Harita üzerinde görsel olarak planladıkları güzergahı takip edebilmektedir
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{rota-planlayici.png}
    \caption{Rota Planlayıcı arayüzü - Ankara bölgesi örnek rota}
    \label{fig:rota-planlayici}
\end{figure}

Şekilde görülen örnekte, Ankara bölgesinde iki gezilecek yer seçilmiştir: "Altınköy Açık Hava Müzesi - Altındağ" ve "Augustus Tapınağı". Harita üzerinde bu noktalar arasındaki rota mavi çizgi ile gösterilmekte, toplam mesafe ve süre bilgisi kullanıcıya sunulmaktadır.

\subsubsection{Rota Optimizasyonu}

Rota planlayıcı, kullanıcının seçtiği yerler arasında en kısa mesafeyi hesaplayarak optimal güzergah oluşturmaktadır. "Rotayı Optimize Et" butonu ile kullanıcılar, durağın sırasını değiştirerek toplam yol mesafesini minimize edebilmektedir.

\subsection{Güvenlik Önlemleri}

\subsubsection{XSS Koruması}

HTML içerikleri, özel karakterler escape edilerek güvenli hale getirilmektedir.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
const escapeHtml = (unsafe = "") => 
  unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
\end{lstlisting}
    \caption{HTML escape fonksiyonu}
    \label{lst:escape-html}
\end{figure}

\subsubsection{Şifre Güvenliği ve Authentication Middleware}

Kullanıcı şifreleri bcrypt ile hash'lenmekte ve JWT ile korumalı endpoint'ler oluşturulmaktadır.

\begin{figure}[H]
    \centering
\begin{lstlisting}[style=JStyle]
// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ 
      error: "Token gerekli" 
    });
  }
  
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ 
        error: "Gecersiz veya suresi dolmus token" 
      });
    }
    req.user = user;
    next();
  });
};

// Korunmali endpoint ornegi
app.get("/api/districts", authenticateToken, 
  async (req, res) => {
  // Sadece giris yapmis kullanicilar erisebilir
  // ...
});
\end{lstlisting}
    \caption{JWT authentication middleware}
    \label{lst:auth-middleware}
\end{figure}

\subsection{Sonuç}

Gezgin Haritası uygulaması, modern web teknolojileri kullanılarak geliştirilmiş, kullanıcı dostu ve güvenli bir platformdur. Vanilla JavaScript ile responsive bir frontend, Node.js ve Express.js ile güçlü bir backend oluşturulmuştur. JWT ile güvenli kimlik doğrulama, SVG tabanlı interaktif harita ile görsel deneyim sağlanmıştır.
